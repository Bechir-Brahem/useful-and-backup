%&latex
\documentclass[10pt]{article}
\usepackage[utf8]{inputenc}
\usepackage{amssymb}
\usepackage{amsmath}
\usepackage{geometry}
\usepackage{listings}
\usepackage{xcolor}
\renewcommand{\baselinestretch}{1.2}
\geometry{
	a4paper,
	total={170mm,257mm},
	left=30mm,
	top=30mm,
}

\definecolor{codegreen}{rgb}{0,0.6,0}
\definecolor{codegray}{rgb}{0.5,0.5,0.5}
\definecolor{codepurple}{rgb}{0.58,0,0.82}
\definecolor{backcolour}{rgb}{0.95,0.95,0.92}

\lstdefinestyle{mystyle}{
	backgroundcolor=\color{backcolour},
	commentstyle=\color{codegreen},
	keywordstyle=\color{magenta},
	numberstyle=\tiny\color{codegray},
	stringstyle=\color{codepurple},
	basicstyle=\ttfamily\footnotesize,
	breakatwhitespace=false,
	breaklines=true,
	captionpos=b,
	keepspaces=true,
	numbers=left,
	numbersep=5pt,
	showspaces=false,
	showstringspaces=false,
	showtabs=false,
	tabsize=2
}

\lstset{style=mystyle}

\begin{document}
%+Title
\title{python}
\author{Bechir Brahem}
\date{\vspace{-5ex}}
\maketitle


\par\noindent\rule{\textwidth}{3pt}
\section{variables }
\textbf{python is dynamically typed} (variables are checked during run time) so no need to mention their types this can be achieved because every python variable is a reference to an object (+ or -).
\begin{lstlisting}[language=Python]
		a=4**0.5
		a="degla"  #no errors
		print a #a is "degla"
\end{lstlisting}
\textbf{Python is strong-typed} (in expressions variables are bound to their specific type)
\begin{lstlisting}[language=Python]
		temp ='Hello World!'
		#temp = temp + 10; program terminates
		#TypeError: cannot concatenate str and int objects
\end{lstlisting}
' and " are treated the same
\begin{lstlisting}[language=Python]
		"hello" , " 'abc " , 'abc'# are allowed
		#"hello' is not allowed
\end{lstlisting}
\section{arithmetic expressions}
\begin{lstlisting}[language=Python]
		a=1/4# (a is 0)
		a=1.0/4# (a is 0.25)
		a=5.0//2# (a is 2.0)
		a=9.0//3.1# (a is 2.0)
		a=9.5//3.1# (a is 3.0)
\end{lstlisting}
if no one is float then it is integer division.
\begin{lstlisting}[language=Python]
		a=2**5# (a is 32)
		a= 4**0.5# (a is 2.0)
\end{lstlisting}
** is exponentiation and can be used with irrationals
\section{Strings}
There are several ways to format strings in Python to interpolate variables.
The new way (new in Python 3.6+) \textbf{F-Strings}
\begin{lstlisting}[language=Python]
			x=10
			formatted = f"i have {x} bbbananas"# formatted = "i have 10 bbbananas"
\end{lstlisting}

the tried and true way(python2 -> 3.5) .format method
\begin{lstlisting}[language=Python]
		x=10
		formatted="i have {} bbbananas".format(10)
\end{lstlisting}
\section{common functions}
insert, append, extend, clear, reverse, sort, count, join
\begin{lstlisting}[language=Python]
		x=[1,2,3,4]
		x.insert(2,"hi") # [1,2,"hi",3,4]
		x.append(8) # [1,2,"hi",3,4,8]
		x,y=[1,2] , [3,4]
		x.append(y) # x=[1,2,[3,4]]
		x,y=[1,2] , [3,4]
		x.extend(y) # x=[1,2,3,4]
		x.clear() # x=[] removes all items from the list
		x=[1,2,3,4]
		x.reverse() # x=[4,3,2,1]
		x.sort() # x=[1,2,3,4]
		x=[1,2,3,4,3,2,1,4,10,2]
		x.count(2) # 3
		x.count(69) # 0
		x=["hi","my","name","is","Alfred"]
		" ".join(x) # "my name is Alfred"
\end{lstlisting}
\textbf{pop:}
\begin{itemize}
	\item removes the item at the given position in the list and reutrn it.
	\item if no index is specified, removes and returns the last item
\end{itemize}
\textbf{remove.}
\begin{itemize}
	\item removes the first item from the list with the given value
	\item throws ValueError if such value doesn't exist
\end{itemize}
\textbf{index.}
\begin{itemize}
	\item returns the first index of the specified value
	\item returns ValueError if such value doesn't exist
\end{itemize}
\section{slices}
[start(included), end(excluded), step]
\begin{lstlisting}[language=Python]
		x=[1,2,3,4,5,6,7]
		x[1:3]=['a','b','c'] # [1,'a','b','c',4,5]
		x=[1,2,3,4,5]
		x[::2] # [1,3,5,7]
		x[::-1]# [7,6,5,4,3,2,1]
\end{lstlisting}
\section{list comprehension}
\begin{lstlisting}[language=Python]
	[num*10 for num in range(1,6)] # [10,20,30,40,50]

	[bool(val) for val in [0, [], '' ]] # [False,False,False]
	
	items=["aaa", "nnn", "qqqq"]
	[item[0]+item[1:] for item in items]
\end{lstlisting}
\begin{lstlisting}[language=Python]
	numbers = [1,2,3,4,5,6]
	evens=[x for x in numbers if x %2==0]
	odds=[x for x in numbers if x%2==1]
\end{lstlisting}
\begin{lstlisting}[language=Python]
	[x*2 if x%2==0 else x/2 for x in numbers]
	[0.5, 4, 1.5, 8, 2.5, 12]
\end{lstlisting}
\begin{lstlisting}[language=Python]
	tmp= "This is so much fun!"
	''.join( y for y in tmp if y not in "aeiou" )
	# "Ths s s mch fn!"
\end{lstlisting}
\section{Data Types.}
\subsection{Dictionnaries}
Dictionary in Python is an unordered collection of data values, used to store data values like a map, which unlike other Data Types that hold only single value as an element, Dictionary holds key:value pairictionary in Python is an unordered collection of data values, used to store data values like a map, which unlike other Data Types that hold only single value as an element, Dictionary holds key:value pair
\textbf{keys can’t be repeated and must be immutable.}
\begin{lstlisting}[language=Python]
	tmp_dictionnary = dcit(key = 'value') #{'key': 'value'}
	Dict = {1: 'Geeks', 2: 'For', 3: 'Geeks'}
	Dict[1] # "Geeks"
	Dict = {'Name': 'Geeks', 1: [1, 2, 3, 4]}
	Dict[1] # [1,2,3,4]
\end{lstlisting}
\textbf{accessing all values in a dict} 
\begin{lstlisting}[language=Python]
	for value in Dict.values():
		print(value)
	#"Geeks",[1,2,3,4]
\end{lstlisting}
\textbf{accessing all keys in a dict} 
\begin{lstlisting}[language=Python]
	for key in Dict.keys():
		print(key)
	#"Name", 1
\end{lstlisting}
\textbf{for both}
\begin{lstlisting}[language=Python]
	x={(1, 2): [1, 2, 3], 1: 'ax', 'alala': 12}
	for key,value in x.items():
		print(key,value)

	#((1,2),[1,2,3])
	#(1,"ax")
	#("alala",12)
\end{lstlisting}
\textbf{check existence.}
\begin{lstlisting}[language=Python]
	x={1:"pp", "name":69}

	1 in x #True
	69 in x # False

	69 in x.values() # True
	[1,2] in x.values() # False
\end{lstlisting}
if the key value already exists, the value gets updated otherwise a new Key with the value is added to the Dictionary.
\begin{lstlisting}[language=Python]
	d={}
	d[1]="aa" # d is {1:"aa"}
	d[(1,2)]={"key":"oop"} # d is {1:"aa", (1,2):{"key","oop"}}
	d[(1,2)]=2 # d is {1:"aa", (1,2):2}
\end{lstlisting}
\textbf{copy}
\begin{lstlisting}[language=Python]
	d=dict(a=1,b=2,c=3)
	c=d.copy()
	c is d # False
	c==d # True
\end{lstlisting}
\textbf{get}
retrieves a key in an object and return None instead of a KeyError if the key doesn't exist
\begin{lstlisting}[language=Python]
	d= dict(a=1,b=2,c=3)
	d['a'] # 1
	d.get('a') # 1
	d["pp"] # KeyError
	d.get("pp") # None
\end{lstlisting}
\textbf{fromkeys}
Creates key-value pairs from comma seperated values and it has no effect on an already created dict:
\begin{lstlisting}[language=Python]
	{}.fromkeys("a","b") # {'a':'b'}
	{}.fromkeys(["email"],"unknown") # {'email': 'unknown'}
	{}.fromkeys("a",[1,2,3,4,5]) # {"a":[1,2,3,4,5]}
	a={1:"pp"}
	a.fromkeys(1,"po") # a is still {1:"pp"}
\end{lstlisting}
\textbf{pop}
takes a single argument corresponding to a key and removes the key:value pair. returns the value associated with the key.
\begin{lstlisting}[language=Python]
	d={1:"q":"b":3}
	d.pop("b") # 3 d is {1:"q"}
	d.pop() # TypeError
	d.pop("o")  # KeyError
\end{lstlisting}
\textbf{update}
update keys and values in a dict with another dict
\begin{lstlisting}[language=Python]
	first=dict(a=1,b=2,c=3)
	second={1:"alfred big"}
	second.update(first)
	second # {"a":1, "b":2, "c":3, 1:"alfred big"}
\end{lstlisting}

\end{document}
