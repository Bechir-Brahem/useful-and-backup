\documentclass[10pt]{article}
\usepackage[utf8]{inputenc}
\usepackage{amssymb}
\usepackage{amsmath}
\usepackage{upquote} % for interpretting backticks `´
\usepackage{geometry}
\usepackage{listings}
\usepackage{tabularx}
\usepackage{xcolor}
\usepackage{graphicx}%package for images
\graphicspath{ {./images/}}%folder of images
\renewcommand{\baselinestretch}{1.1}%distance between lines



\begin{document}
\title{linux notes}
\author{Bechir Brahem}
\date{\vspace{-5ex}} % to remove the date
\maketitle
\noindent\rule{\textwidth}{3pt}


\section{Introduction.}
\paragraph{}
When most people refer to Linux, they are really referring to a combination of software called GNU/Linux, which defines the operating
system. GNU is the free software that provides open source equivalents of many common UNIX commands. The Linux part of this combination
is the Linux kernel, which is the core of the operating system. The kernel is loaded at boot time and stays running to manage every
aspect of the functioning system.
\paragraph{}
The story of Linux begins with UNIX, an operating system developed at AT\&T Bell Labs in the 1970s. UNIX is written in the C language
making it uniquely portable amongst competing operating systems, which were typically closely tied to the hardware for which they
were written. It quickly gained popularity in research and academic settings, as well as amongst programmers who were attracted to
its modularity. Over time it was modified and forked (that is, people modified it, and those modifications served as the basis
for other systems) such that at present there are many different variants of UNIX. However, UNIX is now both a trademark and a
specification, owned by an industry consortium called the Open Group. Only software that has been certified by the Open Group may
call itself UNIX.
\paragraph{}
Linux started in 1991 as a hobby project of Linus Torvalds, a Finnish-born computer scientist studying at the University of Helsinki.
Frustrated by the licensing of MINIX, a UNIX-like operating system designed for educational use, and its creator’s desire not
to make it a full operating system, Linus decided to create his own OS kernel.
\paragraph{}
From this humble beginning, Linux has grown to be the dominant operating system on the Internet, and arguably the most important
computer program of any kind. Despite adopting all the requirements of the UNIX specification, Linux has not been certified,
so Linux really isn’t UNIX! It’s just… UNIX-like.
\paragraph{}
Prior to and alongside this development was the GNU Project, created by Richard Stallman in 1983. While GNU initially focused on
building their own operating system, they ultimately were far more effective at building tools that go along with a UNIX-like
operating system, such as the editors, compilers and user interfaces that make a kernel usable. Since the source was all freely
available, Linux programmers were able to incorporate the GNU tools to provide a complete operating system. As such, many of the
tools and utilities that are part of the Linux system evolved from these early GNU tools.
\section{Operating Systems.}
\subsection{Decision points}
\begin{itemize}
	\item role and required functions
	\item life cycle:\\
		release cycle: the period between upgrades\\
		maintenance cylce or life cycle: endors only support older versions of software for a certain period of time before not offering any updates
	\item
		Stability
	\item
		compatibility
	\item
		cost
	\item
		interface (cli / gui)
\end{itemize}
\subsection{Distributions.}
\includegraphics[width=\textwidth]{distros.png}
\section{Open Source Software and Licensing}

\paragraph{}In most cases, the ownership of the software remains with the person or company that created it. Users are only granted a license
to use the software; this is a matter of copyright law. The money transfer depends on the business model of the creator.
It’s the licensing that differentiates open source software from closed source software.

\paragraph{}With Microsoft Windows, the Microsoft Corporation owns the intellectual property. The license itself, the End User License
Agreement (EULA), is a custom legal document that you must click through, indicating your acceptance, in order to install the
software. Microsoft keeps the source code and distributes only binary copies through authorized channels.

\paragraph{}Two groups can be considered the most influential forces in the world of open source: the Free Software Foundation and the
Open Source Initiative.

\paragraph{}FSF also advocates that software licenses should enforce the openness of modifications. It is their view that if someone modifies
free software that they should be required to share any changes they have made when they share it again. This specific philosophy
is called copyleft. According to FSF, "copyleft is a general method for making a program (or other work) free (in the sense of
freedom, not "zero price" freedom to share, study, and modify the underlying source code.), and requiring all modified and extended versions
of the program to be free as well".
\subsection{Creative Commons.}
\begin{center}
	\begin{tabular}{|l|l|}
		\hline
		Attribution (BY) & All CC licenses require that the creator must be given credit, without \\
						 & implying that the creator endorses the use. \\
						 \hline
		ShareAlike (SA)	 & This allows others to copy, distribute, perform, and modify the work,  \\
						 & provided they do so under the same terms.  \\
						 \hline
		NonCommercial (NC) & This allows others to distribute, display, perform, and modify the work  \\
						   & for any purpose other than commercially. \\
						   \hline
		NoDerivatives (ND) & This allows others to distribute, display, and perform only original copies  \\
						   & of the work. They must obtain the creator’s permission to modify it. \\
						   \hline
	\end{tabular}
\end{center}
\section{CLI and BASH Commands}

\begin{tabular}{|l|l|}

	\hline env				&	to see environment variables\\
	\hline export variable	&	to make a local variable an environment  variable\\
	\hline unset variable	&	to remove exported variables\\
	\hline type \textless command \textgreater	&	to see the command type\\
	\hline which \textless command \textgreater	&	to see which path leads to that command\\
	\hline
\end{tabular}
\subsection{Quotes}
\paragraph{Double quotes} stop the shell from interpreting some metacharacters (special characters), including glob characters
Double quotes still allow for command substitution, variable substitution,
Glob characters, also called wild cards, are symbols that have special meaning to the shell; they are interpreted by the shell
itself before it attempts to run any command. Glob characters include the asterisk \textasteriskcentered   character, the question ? mark character,
and the brackets [ ], among others.

\paragraph{Single quotes} prevent the shell from doing any interpreting of special characters, including globs, variables, command
substitution and other metacharacters that have not been discussed yet.

\paragraph{Backquotes, or backticks}, are used to specify a command within a command, a process called command substitution.
This allows for powerful and sophisticated use of commands `pwd`.
\subsection{Control Statements}
\begin{tabular}{|l|l|}
	\hline
	command1; command2; command3  & executes 1 then 2 then 3 \\
	\hline
	command1 \&\& command2 & executes 2 only if 1 didn't fail \\
	\hline
	command1 \textbar	\textbar   command2 & executes 2 only if 1 failed \\
	\hline
\end{tabular}

\section{comporession and archiving}
\subsection{compressing}
When talking about compression, there are two types:\\
\begin{itemize}
	\item Lossless: No information is removed from the file. Compressing a file		and decompressing it leaves something identical
		to the original.
	\item Lossy: Information might be removed from the file. It is compressed in such a way that uncompressing a file will result
		in a file that is slightly different from the original. For instance, an image with two subtly different shades of green might
		be made smaller by treating those two shades as the same. Often, the eye can’t pick out the difference anyway.
\end{itemize}
\begin{center}
	\begin{tabular}{|l|l|}


		\hline gzip \textless file \textgreater		 & to compress a file and replaces the original with a compressed file.gz\\
		\hline gzip -l \textless file.gz \textgreater	 & to see info about compression \\
		\hline gunzip \textless file.gz \textgreater  & to decompress a file\\
		\hline
	\end{tabular}
\end{center}
\begin{center}
	\begin{tabular}{|l|l|}


		\hline gzip		\textless file\textgreater		  & to compress a file and replaces the original with a compressed file.gz \\
		\hline gzip -l		\textless file.gz\textgreater  & to see info about compression \\
		\hline gunzip  \textless file.gz\textgreater   & to decompress a file\\
		\hline
	\end{tabular}
\end{center}

There is bzip2 and bunzip2, as well as xz and unxz.\\
The gzip command uses the Lempel-Ziv data compression algorithm,
\paragraph{}while the bzip utilities use Burrows-Wheeler block sorting, which can compress files smaller than gzip at the expense of more CPU time.
The xz and unxz tools use the Lempel-Ziv-Markov (LZMA) chain algorithm, which can result in lower decompression CPU times that are
on par with gzip while providing the better compression ratios typically associated with the bzip2 tools.
\\\\
zip [ OPTIONS ] [ zipfile [ file… ] ]\\
zip alpha\_files.zip alpha\textasteriskcentered  \\
-r option for recursive\\
zip -r School.zip School\\
unzip School.zip\\
\subsection{Archiving}
\paragraph{}it combines multiple files into one archive with .tar extension (TApe aRchive)
The tar command has three modes that are helpful to become familiar with:
\begin{itemize}
	\item	Create: Make a new archive out of a series of files.
	\item Extract: Pull one or more files out of an archive.
	\item List: Show the contents of the archive without extracting
\end{itemize}
\subsubsection{Create Mode}
\begin{center}
	\begin{tabular}{|l|l|}
		\hline \multicolumn{2}{|c|}{tar -c [-f ARCHIVE] [OPTIONS] [FILE...]} \\
		\hline -c		&	Create an archive.\\
		\hline -f ARCHIVE &	The argument ARCHIVE will be the name of the resulting archive file.\\
		\hline -z	&		Compress (or decompress) an archive using the gzip command.\\
		\hline -j &			Compress (or decompress) an archive using the bzip2 command.\\
		\hline -v & for  verbose mode\\
		\hline
	\end{tabular}
\end{center}
tar -cjf folders.tbz School\ \ \ \ \ \ \ \ \ \ : to create a compressed archive of the directory school\\
tar -czf alpha\_files.tar.gz alpha\textasteriskcentered\ : to create a compressed archive of alpha\textasteriskcentered   files and dirs

\subsubsection{List Mode.}
Given a tar archive, compressed or not, you can see what’s in it by using the -t option. (used with f option)\\
tar -tf  moo.tar.gz : to view contents of the compressed archive

\subsubsection{Extract Mode.}
\begin{center}
	\begin{tabular}{ l l }

		\multicolumn{2}{ c }{tar -x [ -f ARCHIVE ] [ OPTIONS ]}\\
		tar -xjf folders.tbz & to extract files from the archive\\
		tar -xjvf folders.tbz School/Art/linux.txt & to extract a specific file\\

	\end{tabular}
\end{center}


\section{Working With Text.}
there are 3 streams (or channels) where text is displayed:\\
\begin{center}
	\begin{tabular}{ l l }

		stdout &file descriptor 1\\
		stderr &file descriptor 2\\
		stdin  &file descriptor 0\\

	\end{tabular}
\end{center}

\begin{center}
	\begin{tabular}{ l l }


		Use the redirection symbol \textgreater  & deletes content of a file then redirects output of stdout to the file\\
		the  \textgreater \textgreater  symbol & append the output to the file\\
		2\textgreater & to direct only stdout\\
		1\textgreater & to direct only stderr\\
	\end{tabular}
\end{center}
Another form of redirection is to send the output of one command and send it to another with \textbar\\
\begin{center}
	\begin{tabular}{|l|l|}

		\hline
		more & to view long files space to move to the next page\\
		less & to view long text files  \textless\textgreater  to move to the next page\\
		head & to view first 5 lines\\
		tail & to view last 5 lines\\
		grep & can be used with regex\\
		fgrep& interpret characters literally\\
		\hline\multicolumn{2}{ |c| }{grep \textless pattern\textgreater  \textless file\textgreater}\\
		\hline
	\end{tabular}
\end{center}
\subsection{Regular Expressions.}
\begin{center}
	\begin{tabular}{|l|l|}
		\hline.    & any single character\\
		\hline{[\ ]}& A list or range of characters to match one character If the first character within the brackets \\
					&is the caret	\textasciicircum, it means any character not in the list\\
		\hline\textasteriskcentered &  the previous character repeated zero or more times\\
		\hline\textasciicircum & if \textasciicircum is used at the begining the pattern must be at the begging of the line match\\
		\hline\textdollar & if this one is used at the end the pattern must be at the end of the file\\
		\hline\textbackslash & to use the next character as literal\\\hline
	\end{tabular}
\end{center}
use '' around the pattern to prevent the shell from interpreting the regex\\
\textbf{examples.}\\
\begin{center}
	\begin{tabular}{l l}


		grep '\textasciicircum  root' passwd & to search for lines that start with root\\
		grep 'sync\textdollar ' passwd & to search for lines that end with sync\\
		grep '.y' passwd & to search for lines that contain any character followed by y\\
		grep -E or egrep & is used for extended regex\\

	\end{tabular}
\end{center}

\section{Basic Shell Scripting}
There are various shells with their own language syntax. Therefore, more complicated scripts will indicate a
particular shell by specifying the absolute path to the interpreter as the first line, prefixed by \#! like: \\
\#!/bin/bash\\
\subsection{Variables.}
\begin{verbatim}
ANIMAL="penguin"
echo "My favorite animal is a $ANIMAL"
\end{verbatim}
it is necessary to have no spaces in the variable assignment\\
capitalizing the var name is a convention\\
\begin{verbatim}
ANIMAL="penguin"
SOMETHING=$ANIMAL

CURRENT_DIRECTORY=`pwd`
echo "You are in $CURRENT_DIRECTORY"
\end{verbatim}
\textdollar 0 is the name of the script file\\
\textdollar 1 is the first argument ...\\
\subsection{conditionals.}
\begin{verbatim}
if somecommand; then
# do this if somecommand has an exit code of 0
fi
\end{verbatim}

The test command gives you easy access to comparison and file test operators. For example:\\
\begin{center}
	\begin{tabular}{|l|l|}
		\hline
		test –f /dev/ttyS0			& 0 if the file exists\\
		test ! –f /dev/ttyS0			& 0 if the file doesn’t exist\\
		test –d /tmp					& 0 if the directory exists\\
		test –x `which ls`				& substitute the location of ls then test if the user can execute\\
		test 1 –eq 1					& 0 if numeric comparison succeeds\\
		test 1 –ne 1					& test for numeric inequality\\
		test “a” = “a”					& 0 if the string comparison succeeds\\
		test “a” != “a”					& 0 if the strings are different\\
		test 1 –eq 1 –o 2 –eq 2			& -o is OR: either can be the same\\
		test 1 –eq 1 –a 2 –eq 2			& -a is AND: both must be the same\\

		\hline
	\end{tabular}
\end{center}

If you enclose your conditions in square brackets, it’s the same as running test. So, these statements are identical.\\
\begin{verbatim}
if test –f /tmp/foo; then
if [ -f /tmp/foo]; then
\end{verbatim}
antother example:
\begin{verbatim}
if [ "\textdollar 1" = "hello" ]; then
echo "hello yourself"
elif [ "\textdollar 1" = "goodbye" ]; then
echo "nice to have met you"
echo "I hope to see you again"
else
echo "I didn't understand that"
fi
\end{verbatim}

\subsection{loops.}
\begin{verbatim}

for loop:
SERVERS="servera serverb serverc"
for S in $SERVERS; do
echo "Doing something to $S"
done

for S in *  ; do
echo "Doing something to $S"
done
this one operates on all the files
while loop:

i=0
while [ $i -lt 10 ]; do
echo $i
i=$(( $i + 1))
done

while [ condition ]; do
#do stuff
done
i=$(( $i + 1)) this one is for incrementing

\end{verbatim}
\section{Hardware.}
\begin{center}
	\begin{tabular}{|l|l|}
		\hline
		arch & for computer architecture 64/32\\
		free -h & to see how much memory is used -h for human readable\\
		lscpu & to see cpu info\\
		lspci [-k to display the driver] & to see pci hardware\\
		lsusb & see connected usb devices\\
		\hline
	\end{tabular}
\end{center}
\section{Hard Drives.}
\paragraph{}
Some hard drives make use of a partitioning technology called Master Boot Record (MBR) while others make use
of a partitioning type called GUID Partitioning Table (GPT). The MBR type of partitioning has been used since the early
days of the Personal Computer (PC), and the GPT type has been available since the year 2000.

\paragraph{}
An old term used to describe an internal hard disk is fixed disk, as the disk is fixed (not removable). This term gave rise to several command names: the fdisk, cfdisk and sfdisk commands, which are tools for working with the MBR partitioned disks.

\paragraph{}
The GPT disks use a newer type of partitioning, which allows the user to divide the disk into more partitions than what MBR supports. GPT also allows having partitions which can be larger than two terabytes (MBR does not). The tools for managing GPT disks are named similarly to their fdisk counterparts: gdisk, cgdisk, and sgdisk.
There is also a family of tools that attempt to support both MBR and GPT type disks. This set of tools includes the parted command and the graphical gparted tool.
Hard drives are associated with file names (called device files) that are stored in the /dev directory. Each device file name is made up of multiple parts.
File Type
\paragraph{}
The file name is prefixed based on the different types of hard drives. IDE (Intelligent Drive Electronics) hard drives begin with hd, while USB, SATA (Serial Advanced Technology Attachment) and SCSI (Small Computer System Interface) hard drives begin with sd.
Device Order
\paragraph{}
Each hard drive is then assigned a letter which follows the prefix. For example, the first IDE hard drive would be named /dev/hda and the second would be /dev/hdb, and so on.
Partition
\paragraph{}
Finally, each partition on a disk is given a unique numeric indicator. For example, if a USB hard drive has two partitions, they could be associated with the /dev/sda1 and /dev/sda2 device files.
\\
\begin{tabular}{l l}
	fdisk & can be used to show further information\\
	example: & fdisk -l or fdisk -l /dev/sda\\
\end{tabular}
\section {where data is stored}
\subsection{processes}
\paragraph{}
not only contains information about running processes, as its name would suggest, but it also contains information about the system hardware and the current kernel configuration.\\
ls /proc : you can see files numbered with PID numbers they are pseudo files because they are contained in memory (RAM)
\begin{center}
	\begin{tabular}{ l l }

		/proc/cmdline		& Information that was passed to the kernel when it was first started, such as\\
							&command line parameters and special instructions\\
		/proc/meminfo		& Information about the use of memory by the kernel\\
		/proc/modules		& A list of modules currently loaded into the kernel to add extra functionality\\

	\end{tabular}
\end{center}
\paragraph{}
When the kernel finishes loading during the boot procedure, it starts the init process and assigns it a PID of 1 ( systemd )
\begin{center}
	\begin{tabular}{|l|l|}
		\hline


		pstree &Processes can be “mapped” into a family tree of parent and child couplings.\\
		ps  &shows processes running from this shell\\
		ps aux or -ef &to show all processes can be piped to grep\\
		top  &shows processes and the used ressources updated in real time\\
			 & -K		Terminate the runaway process.\\
			 &-R		Adjust the priority of the process.\\
			 \hline
	\end{tabular}
\end{center}
\subsection{log files}
\paragraph{}
Syslog is the term that is used almost generically to describe logging in Linux systems\\
Some processes can log their own data to these files, other processes rely on a separate process (a daemon) to handle these log data files.
Logging daemons differ in two main ways in recent distributions. The older method of doing system logging is two daemons (named syslogd and klogd) working together, but in more recent distributions, a single service named rsyslogd combines these two functions and more into a single daemon.
In yet more recent distributions, those based on systemd, the logging daemon is named journald\\
\begin{center}
	journalctl -r:  The standard method for viewing journald-based logs -r for reverse\\
\end{center}
the log files themselves are almost always placed into the /var/log directory structure
\begin{center}
	\begin{tabular}{|l|l|}

		\hline boot.log			&Messages generated as services are started during the startup of the system.
		\\ \hline	cron		&Messages generated by the crond daemon for jobs to be executed on a recurring basis.
		\\ \hline	dmesg		&Messages generated by the kernel during system boot up.
		\\ \hline	maillog		&Messages produced by the mail daemon for e-mail messages sent or received.
		\\ \hline	messages	&Messages from the kernel and other processes that don't belong elsewhere. Sometimes named\\
								&syslog instead of messages after the daemon that writes this file.
		\\ \hline	secure		&Messages from processes that required authorization or authentication (such as the login process).
		\\ \hline	journal		&Messages from the default configuration of the systemd-journald.service; can be configured in\\
								&the /etc/journald.conf file amongst other places.
		\\ \hline	Xorg.0.log	&Messages from the X Windows (GUI) server.\\
		\hline
	\end{tabular}
\end{center}

\subsection{Filesystem Hierarchy Standard}
\begin{center}
	\begin{tabular}{|l|l|}
		\hline/				&The base of the structure, or root of the filesystem
		\\ \hline/bin		&Essential binaries like the ls, cp, and rm commands, and be a part of the root filesystem
		\\ \hline/boot		&Files necessary to boot the system, such as the Linux kernel and associated configuration files
		\\ \hline/dev		&Files that represent hardware devices and other special files, such as the /dev/null\\
							& and /dev/zero files
		\\ \hline/etc		&Essential host configurations files such as the /etc/hosts or /etc/passwd files
		\\ \hline/home		&User home directories
		\\ \hline/lib		&Essential libraries to support the executable files in the /bin and /sbin directories
		\\ \hline/lib64		&Essential libraries built for a specific architecture. For example, the /lib64 directory \\
							&for 64-bit AMD/Intel x86 compatible processors
		\\ \hline/media		&Mount point for removable media mounted automatically
		\\ \hline/mnt		&Mount point for temporarily mounting filesystems manually
		\\ \hline/opt		&Optional third-party software installation location
		\\ \hline/proc		&Virtual filesystem for the kernel to report process information, as well as other information
		\\ \hline/root		&Home directory of the root user
		\\ \hline/sbin		&Essential system binaries primarily used by the root user
		\\ \hline/sys		&Virtual filesystem for information about hardware devices connected to the system
		\\ \hline/srv		&Location where site-specific services may be hosted
		\\ \hline/tmp		&Directory where all users are allowed to create temporary files and that is supposed to be\\
							& cleared at boot time (but often is not)
		\\ \hline/usr		&Second hierarchy Non-essential files for multi-user use
		\\ \hline/usr/local	&Third hierarchy Files for software not originating from distribution
		\\ \hline/var		&Fourth hierarchy Files that change over time
		\\ \hline/var/cache	&Files used for caching application data
		\\ \hline/var/log	&Most log files
		\\ \hline/var/lock	&	Lock files for shared resources
		\\ \hline/var/spool	&Spool files for printing and mail
		\\ \hline/var/tmp	&Temporary files to be preserved between reboots\\
		\hline
	\end{tabular}
\end{center}

\section{network}
Primary IPv4 Configuration File\\
\begin{center}
	\begin{tabular}{l l}
		/etc/NetworkManager/system-connections & contains connections info\\
		/etc/network/interfaces &config file\\
	\end{tabular}
\end{center}
\begin{center}
	\begin{tabular}{|l l|}
		\hline
		sudo service network-manager restart &to restart the whole network system and \\
											 &load new(if changed) config files\\
											 \hline
	\end{tabular}
\end{center}

\subsection{DNS}
\begin{center}
	\begin{tabular}{l l}


		/etc/hosts				&This file contains a table of hostnames to IP addresses. It can be used to\\
								&supplement a DNS server.
		\\/etc/resolv.conf		&This file contains the IP addresses of the name servers the system should\\
								&consult in any attempt to resolve names to IP addresses. These servers are\\
								&often DNS servers. It also can contain additional keywords and values that\\
								&can affect the resolution process.
		\\/etc/nsswitch.conf	&This file can be used to modify where hostname lookups occur. It contains\\
								&a particular entry that describes in what order name resolution sources\\
								&are consulted.\\
	\end{tabular}
\end{center}
nsswitch.conf can have this line\\
hosts:files dns : this way The /etc/hosts file is searched first, the DNS server second\\
hosts: dns files : The DNS server would be searched first, local files second\\
\begin{center}
	\begin{tabular}{l l}
		host example.com &returns ip of example(solve domain) or host 178.393.39.3 returns domain\\
		dig google.com &to see the DNS server detailed response\\
	\end{tabular}
\end{center}

\subsection{network tools}
\begin{center}
	\begin{tabular}{|l|l|}
		\hline
		ifconfig & to see information about network intefaces(deprecated)\\
		\hline ip -c addr & to see information about network interfaces -c for colors\\
		\hline netstat -i   & to display statistics regarding network traffic\\
		\hline netstat -tln & to view open ports -t tcp -l list -n numerical( sometimes without n is better)\\
		\hline ss &netid socket type/ state active or not/ recv and sendv are queues\\
		\hline ss -s &displays mostly the types of sockets statistics\\
		\hline ssh &connect to another computer ssh bob@alfred(or ip) to connect to as my user to bob\\
		\hline
	\end{tabular}
\end{center}

\section{user and accounts}
\paragraph{}
linux supports multiple users each user has a specific UID and also linux supports groups.each group has a specific GID.
A user must have a primary group and can be part of several others.
In some Linux distributions, particularly those based upon Red Hat, when a user ID (UID) is created, a user private group (UPG) is also created with that user as its only member. In these distributions, the UID and the ID of the UPG are supposed to match.
\begin{center}
	\begin{tabular}{|l|l|}

		\hline su& to change accounts(uid) (-l to login)\\
		\hline id& to see the running user\\
		\hline who or w &display logged in users\\
		\hline last  & shows the logs of logins\\
		\hline /etc/passwd & has the users and their groups at the end\\
		\hline /etc/shadow & has the passwords\\
		\hline /etc/group & has the groups\\
		\hline  \multicolumn{2}{|c|}{GIDs under 1000 for debian 500 for red hat are generally used for system groups} \\
		\hline groups & to see the groups the user has\\
		\hline groupadd & to add a a group (-g to speciy gid) (-r to add a system group GID\textless 1000 )\\
		\hline groupmod & to modify a group (-n to change the name and keep gid) (-g changes gid and files \\
						&owned by this group will be unaccessible)\\
		\hline newgrp & to change your current primary group (just in that shell)\\
		\hline find / -nogroup & to find files owned by no one (called orphaned files)\\
		\hline groupdel & deletes a group that is no user's primary group and files will be orphaned\\
		\hline
	\end{tabular}
\end{center}
\begin{center}
	\begin{tabular}{l|l}
		\textbf{useradd} &useradd will use the default config found with useradd -D\\
						 &-u specify uid\\
						 &-g specify a primary group\\
						 &-G suplementary group\\
						 &-b to specify home dir\\
						 &-m to add a home dir (in /home/example)\\
		\textbf{usermod} & to modify user\\
		\textbf{userdel} & to delete user -r to remove home dir\\
	\end{tabular}
\end{center}

\section{ownership and permissions.}
\begin{center}
	\begin{tabular}{l l}
		chgrp & change the group owner of an existing file
		\\stat & shows more details about files ownership and permissions
		\\chown & to change the file's user (can be used chown user:group file to change both)
	\end{tabular}
\end{center}
when typing ll you get for example "- rw- r-- r--"\\
first letter is for the nature of the file d for dir - for file (can be other letters)
the next nine characters demonstrate the permissions of the file.\\
\begin{center}
	\begin{tabular}{|l|l|l|}
		\hline first three& user owner & permissions for the user that owns the file\\
		\hline second three& group owner & permissions for the group that owns the file\\
		\hline last three& others & This group includes all users who are not the file owner\\
						 & &or a member of the file's group.\\
						 \hline
	\end{tabular}
\end{center}
\begin{center}
	\begin{tabular}{l l}
		read: r      &\\
		write: w      &these depend on the nature of the file (dir or file)\\
		execute:x &\\
	\end{tabular}
\end{center}
if the privelege is attributed it gets a character other wise it is marked with -\\
\textbf{Read:}
\begin{itemize}
	\item On a file, this allows processes to read the contents of the file, meaning the contents can be viewed and copied.
	\item On a directory, file names in the directory can be listed, but other details are not available.
\end{itemize}
\textbf{Write:}
\begin{itemize}
	\item A file can be written to by the process, so changes to a file can be saved. Note that w permission really requires r permission on the file to work correctly.
	\item On a directory, files can be added to or removed from the directory. Note that w permission requires x permission on the directory to work correctly.
\end{itemize}
\textbf{Execute:}
\begin{itemize}
	\item A file can be executed or run as a process.
	\item On a directory, the user can use the cd command to "get into" the directory and use the directory in a pathname to access files and, potentially, subdirectories under this directory.
\end{itemize}
\begin{center}
	\begin{tabular}{|l|}
		\hline
		\textbf{chmod} command is used to change the file permissions (only owner or root)\\
		\hline
	\end{tabular}
\end{center}
There's two ways first one:\\

\begin{itemize}
	\item \textbf{the symbolic method}\\
		\resizebox{0.6\textwidth}{!}{%
			\begin{tabular}{|l|l|l|l|}
				\hline
				u: user &g: group   &o: other &a: all  \\ \hline
				+ add privelege  & \multicolumn{2}{l|}{-  remove privelege } &= to make it equal  \\ \hline
			\end{tabular}%
		}\\
		examples:
		\begin{center}
			\begin{tabular}{l l}
				chmod g+w file  &adds write privelege to the group owner\\
				chmod ug+x,o-r file & adds x for users and group and remove r from others\\
				chmod u=rx file & now the user permissions are r-x\\
			\end{tabular}
		\end{center}


	\item \textbf{the numeric method:}\\
		like binary system r represents 4, w represents 2, x represents 1\\
		rwx is 7, --- is 0, r-- is 4, -w- is 2, r-x is 5\\
		example:\\
		chmod 754 file : permission for file now is rwxr-xr--

\end{itemize}
\section{special files and dirs.}
\subsection{setuid}
\begin{center}
	\begin{tabular}{|l|}
		\hline
		When the setuid permission is set on an executable binary file (a program)the binary file \\is run as its owner, not as the user who executed it\\
		\hline
	\end{tabular}
\end{center}
passwd command has this proprety because it can be run with a normal user and it can access shadow file as root\\
ls -l /usr/bin/passwd gives: -rwsr-xr-x root root : the s is for setuid\\
\begin{center}
	\begin{tabular}{l l}
		chmod u+s file or chmod 4775 file (add 4000)& to add setuid to a file\\
		chmod u-s file or chmod 0775 file (substract 4000)& to remove setuid from a file\\
	\end{tabular}
\end{center}
\subsection{Setgid}
The setgid permission is similar to setuid, but it makes use of the group owner permissions. There are two forms of setgid
permissions: setgid on a file and setgid on a directory.\\
\subsubsection{Setgid on Files:}
allows a user to run an executable binary file in a manner that provides them additional group access
\subsubsection{setgid on Directories:}
When set on a directory, the setgid permission causes files created in the directory to be
owned by the group that owns the directory automatically\\\\
a lowercase s meants the setgitd and groupe execute permissions are set\\
An uppercase S means that only setgid and not group execute permission is set\\
\begin{center}
	\begin{tabular}{l l}
		chmod g+s \textless file\textgreater  or chmod 2775 \textless file\textgreater  (add 2000) & to add setgid to a file\\
		chmod g-s \textless file\textgreater  or chmod 0775 \textless file\textgreater  (substract 2000)& to rm setgid permissions\\
	\end{tabular}
\end{center}

\subsection{sticky bit}
\begin{center}
	\begin{tabular}{|l|}
		\hline
		The sticky bit permission is used to prevent other users from deleting files that they do not own\\
		in a shared directory Recall that any user with write permission on a directory can create files\\
		in that directory, as well as delete any file in the directory, even if they do not own the file!\\
		\hline
	\end{tabular}
\end{center}
executing ls -ld /tmp gives drwxrwxrwt\\\\
A lowercase t means that both the sticky bit and execute permissions are set for others.\\
An uppercase T means that only the sticky bit permission is set.\\
\begin{center}
	\begin{tabular}{l l}
		chmod o+t \textless dir\textgreater  or chmod 1775 \textless dir\textgreater  (add 1000) & to add the sticky bit permission\\
		chmod o-t \textless dir\textgreater  or chmod 0775 \textless dir\textgreater  (remove 1000)& to remove sticky bit permission\\
	\end{tabular}
\end{center}

\subsection{hard links}
Every file on a partition has a unique identification number called an \textbf{inode number}\\
what defines a file is not its name, but rather the number it has been assigned.
The inode table does not include the file name. For each file, there is
also an entry that is stored in a directory's data area (data block) that includes
an association between an inode number and a file name.\\
ls -i : shows the inode number\\
\begin{center}
	\begin{tabular}{l l}

		ln \textless target\textgreater  \textless link-name\textgreater	  &to create a hard link\\
	\end{tabular}
\end{center}
\subsection{soft links}
A symbolic link, also called a soft link, is simply a file that points to another file.
can be used to link dirs ( unlike hard links ) they are just like shortcuts in windows\\
\begin{center}
	\begin{tabular}{l l}
		ln -s \textless file\textgreater  \textless link\textgreater  &to create a symlink supply fullpath for the file

	\end{tabular}
\end{center}
\subsection{Comparing Hard and Symbolic Links}
\begin{itemize}
	\item \textbf{Hard links don’t have a single point of failure.}if you delete the source you can still access the link but with symlink if you delete source you can't access file anymore
	\item   \textbf{Soft links can link to any file.}Since each file system (partition) has a separate set of inodes, hard links cannot be created that attempt to cross file systems and symlinks can
	\item   \textbf{Soft links can link to a directory.}
\end{itemize}
\end{document}
